//#include "../include/global.h"
//#include "../include/constants.h"

#pragma OPENCL EXTENSION cl_khr_byte_addressable_store: enable
#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable
#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable
#define ungappedExtension_UNGAPPED 1
#define NULL 0
#define constants_max_short 32767
#define TARGET_THREAD 0
#define UNGAPEXT_PER_THREAD 150
#define TOTAL_UNGAPPED_EXT 1500000
struct PSSMatrixFP
{
	int length;
	int strandLength;
	int highestValue;
	int lowestValue;
__global	short* matrix;
    unsigned char* queryCodes;
	unsigned char* bestMatchCodes;
	unsigned char* bytePackedCodes;
	unsigned char* xorCodes;
};


struct sequenceDataFP
{
	uint sequenceLength;
	uint descriptionStart;
	uint descriptionLength;
	uint encodedLength;
    uint offset;
};

typedef struct strTimeRecord {
	uint iniTime;
	uint preProcessTime;
	uint dataCopyTimeH2D;
	uint searchTime;
	uint dataCopyTimeD2H;
	uint addUngappedExtensionTime;
	uint postProcessTime;
	uint hitUngappedExtTime;
	uint gappedAlignmentTime;
	uint finalAlignmentTime;
	uint totalTime;
} TIMERECORD;

struct __attribute__((aligned)) coordinate
{
    int queryOffset;
	int subjectOffset;
};

struct __attribute__ ((aligned)) ungappedExtension
{
	int nominalScore;
	//Shucai
	uint sequenceCount;
	uint tid;
	struct ungappedExtension* next;
	struct coordinate start;
	struct coordinate end;
	struct coordinate seed;
	int status; //char status;
//	char pad[11];
};

//__global unsigned char* wordLookupDFA;
//__constant unsigned char * wordLookupDFA;
struct groupFP   //for parallelization
{
	int nextWords;
	int nextGroups;
};
//__constant struct groupFP  *wordLookupDFA_groupsFP;
__constant TIMERECORD timeRecord;

//texture<unsigned char, 1> texSubjectSequences;

struct parameters {
	int 	wordLookupDFA_numCodes;
	uint	additionalQueryPositionOffset;
	int	statistics_ungappedNominalDropoff;
	int	blast_ungappedNominalTrigger;
	int    parameters_A;
	uint	ungappedExtensionsPerThread;
	uint	ungappedExtAdditionalStartLoc;
	char 	parameters_wordSize;
	unsigned char encoding_numCodes;
	char    parameters_overlap;
};


__global struct ungappedExtension *ungappedExtension_oneHitExtendD(unsigned char *, int, unsigned
char*, 
	struct PSSMatrixFP, unsigned char*, uint *, unsigned char, int, int,
	struct ungappedExtension *, uint *, uint, int);
struct coordinate ungappedExtension_findProteinSeed(struct ungappedExtension*,
		   struct PSSMatrixFP, unsigned char*, unsigned char);

//__device__ __constant__ struct groupFP wordLookupDFA_groupsC[400];
//This doesn't seem to be used right now oddly enough
//__constant const short scoreMatrixC[1640];
__constant unsigned char querySequenceC[40000];
__constant uint global_sequenceCount;
__constant uint global_numAdditionalTriggerExtensions;

/*************************************************************************
 *  The following functions are for 2-hit extension
 *************************************************************************/
__global struct ungappedExtension* ungappedExtension_twoHitExtendD(unsigned char* sequenceStart,
						int queryOffset, 
						unsigned char *subjectHit,
						uint lastHitFP,
						struct PSSMatrixFP PSSMatrixFP, unsigned char *subject,
						uint *sequenceHitEnd, unsigned char encoding_numCodes,
						int statistics_ungappedNominalDropoff,
						int blast_ungappedNominalTrigger,
						int ungappedExtensionsPerThread,
						struct ungappedExtension *ungappedExtension_extensions,
						struct ungappedExtension *ungappedExtension_additonal,
						uint *numOfTriggerExtensions,
						uint sequenceCount,
						int tid)
{
__global	short* queryPosition;
	unsigned char* subjectPosition, *subjectStart, *subjectEnd;
	int changeSinceBest = 0;
	int dropoff, originalDropoff;
	int ungappedExtension_bestScore;

	originalDropoff = dropoff = -statistics_ungappedNominalDropoff;	
	ungappedExtension_bestScore = 0;

	// Start at queryEnd,subjectEnd (right/last hit position)
	queryPosition = PSSMatrixFP.matrix + queryOffset * encoding_numCodes;
	subjectPosition = subjectStart = subjectHit;
	
	while (changeSinceBest > dropoff)
	{
		changeSinceBest += queryPosition[*subjectPosition];

		// If we have got a positive score
		if (changeSinceBest > 0)
		{
			// Keep updating best score and resetting change-since-best
			// whilst we are reading positive scores
			do
			{
				ungappedExtension_bestScore += changeSinceBest;
				queryPosition = queryPosition - encoding_numCodes;
				subjectPosition--;

				changeSinceBest = queryPosition[*subjectPosition];
			}
			while (changeSinceBest > 0);

			subjectStart = subjectPosition;
		}

		queryPosition = queryPosition - encoding_numCodes;
		subjectPosition--;
	}

	// Correct for extra decrement
	subjectStart++;

	if (subjectStart - sequenceStart > lastHitFP)
	{
		*sequenceHitEnd = subjectHit - sequenceStart;
		return NULL;
	}

	// Starting at right/last hit position again
	queryPosition = PSSMatrixFP.matrix + (queryOffset + 1) * encoding_numCodes;
	subjectPosition = subjectHit + 1;
	subjectEnd = subjectHit;
	changeSinceBest = 0;

	// May need to alter dropoff so we also dropoff if below zero
	if (-ungappedExtension_bestScore > originalDropoff)
	{
		dropoff = -ungappedExtension_bestScore;
	}

	// Extend end of alignment until dropoff
	while (changeSinceBest > dropoff)
	{
		//Shucai
		changeSinceBest += queryPosition[*subjectPosition];

		// If we have got a positive score
		if (changeSinceBest > 0)
		{
			// Keep updating best score and resetting change-since-best
			// whilst we are reading positive scores
			do
			{
				ungappedExtension_bestScore += changeSinceBest;
				queryPosition = queryPosition + encoding_numCodes;
				subjectPosition++;
				changeSinceBest = queryPosition[*subjectPosition];
			}
			while (changeSinceBest > 0);

			subjectEnd = subjectPosition;
			
			// Check need for change in dropoff
			if ((dropoff = -ungappedExtension_bestScore) < originalDropoff)
			{
				dropoff = originalDropoff;
			}
		}
		queryPosition = queryPosition + encoding_numCodes;
		subjectPosition++;
	}

	subjectEnd--;

	*sequenceHitEnd = subjectEnd - sequenceStart;

	if (ungappedExtension_bestScore >= blast_ungappedNominalTrigger)
	{
		int diagonal;
//		struct ungappedExtension* newUngappedExtension = 0;
struct ungappedExtension* newUngappedExtension = NULL;
		
		if ((*numOfTriggerExtensions) >= ungappedExtensionsPerThread)
		{
			newUngappedExtension = &ungappedExtension_additonal[atom_add((__global int*)((int)&(global_numAdditionalTriggerExtensions)), 1)];
		}
		else
		{
			newUngappedExtension = &ungappedExtension_extensions[(*numOfTriggerExtensions)];
		}

		// Calculate diagonal
		diagonal = (subjectHit - subject) - queryOffset;

		// Determine offsets from pointers
		newUngappedExtension->start.subjectOffset = subjectStart - subject;
		newUngappedExtension->end.subjectOffset = subjectEnd - subject;
		newUngappedExtension->start.queryOffset = newUngappedExtension->start.subjectOffset - diagonal;
		newUngappedExtension->end.queryOffset = newUngappedExtension->end.subjectOffset - diagonal;
		newUngappedExtension->seed = ungappedExtension_findProteinSeed(newUngappedExtension, 
									 PSSMatrixFP, subject, encoding_numCodes);

		newUngappedExtension->next = NULL;
		newUngappedExtension->nominalScore = ungappedExtension_bestScore;
		newUngappedExtension->status = ungappedExtension_UNGAPPED;
		newUngappedExtension->sequenceCount = sequenceCount;
		newUngappedExtension->tid = tid;

		//Shucai
		//Record the number of hits satisfying the next step
		(*numOfTriggerExtensions)++;
		

		return (__global struct ungappedExtension*)((int)(newUngappedExtension));
	}
	else
	{
		return 0;
//		return NULL;
	}

}

//Embarrassingly parallel approach is used. One thread is used for
//the hit detection of one sequence
__kernel void search_protein1hitKernel(__global struct PSSMatrixFP *PSSMatrixFP,
										 __global short *matrixBody,
									  	 __global struct sequenceDataFP *sequenceDataFP, 
										 __global unsigned char *sequence,
										 __global struct parameters *parametersFP,
										 __global struct groupFP *wordLookupDFA_groupsFP,
										 __global unsigned char *wordLookupDFAFP,
										 __global uint *blast_numUngappedExtensions,
										 __global uint *blast_numTriggerExtensions,
										 __global uint *blast_numHits,
										 __global uint *hitMatrix_furthestp,
										 __global uint *hitMatrix_offsetp,
										 __global struct ungappedExtension * ungappedExtension_extensionsp,
										 uint nTotalSequenceNum)
{
	int bid = get_local_id(1) * get_global_size(2) + get_local_id(2);
//	int bid = blockIdx * gridDim.y + blockIdx.y;
	int tid = bid * get_local_size(1) * get_local_size(2) + get_group_id(1) * get_local_size(2) + get_group_id(2);
//	int tid = bid * blockDim * blockDim.y + threadIdx * blockDim.y + threadIdx.y;

	unsigned char *subject, *sequenceEnd, *address;
	int subjectOffset, count;
	unsigned char currentWord, *currentBlock;
	struct groupFP *currentGroupFP;
	ushort *wordLookupDFA_AddiPositions;
	uint numOfTriggerExtensions = 0;
	ushort *queryOffsets, queryOffset;
	__global struct ungappedExtension* ungappedExtension_current;
	int diagonal;
	uint *lastHitFP;
	uint ungappedExtension_subjectEndReachedFP;
	uint *hitMatrix_Local;
	uint sequenceCount;

//The nasty type-conversion here is a hack to "allow" pointers to global memory space to be stored in private variables.
//We use it extensively throughout this kernel file. -Paul
	hitMatrix_Local = (uint *)((int)(hitMatrix_furthestp + hitMatrix_offsetp[tid] + PSSMatrixFP->length));
	ungappedExtension_extensionsp->start.subjectOffset = 0;
	ungappedExtension_current = (struct ungappedExtension *)((int)(ungappedExtension_extensionsp + tid * UNGAPEXT_PER_THREAD));
	wordLookupDFA_AddiPositions = (ushort *)((int)(wordLookupDFAFP + parametersFP->additionalQueryPositionOffset));

	//Set the PSSMatrix body
PSSMatrixFP->matrix= (__global short *)((int)(matrixBody + parametersFP->encoding_numCodes));//	PSSMatrixFP->matrix = (short *)((int)(matrixBody + parametersFP->encoding_numCodes));

	sequenceCount = tid;
	while (sequenceCount < nTotalSequenceNum)
	{
		subject = address = (unsigned char *)((int)(sequence + sequenceDataFP[sequenceCount].offset));
		
		if (sequenceDataFP[sequenceCount].sequenceLength >= parametersFP->parameters_wordSize)
		{
			currentGroupFP = (struct groupFP *)((int)(wordLookupDFA_groupsFP));
			//currentGroupFP = wordLookupDFA_groupsC;

			count = 1;
			while (count < parametersFP->parameters_wordSize)
			{
				if (*address < parametersFP->wordLookupDFA_numCodes)
				{
					currentGroupFP = (struct groupFP *)((int)(&wordLookupDFA_groupsFP[currentGroupFP->nextGroups + *address]));
					//currentGroupFP = &wordLookupDFA_groupsC[currentGroupFP->nextGroups + *address];
				}
				else
				{
					currentGroupFP = (struct groupFP *)((int)(&wordLookupDFA_groupsFP[currentGroupFP->nextGroups]));
					//currentGroupFP = &wordLookupDFA_groupsC[currentGroupFP->nextGroups];
				}
				address++;
				count++;
			}

			sequenceEnd = subject + sequenceDataFP[sequenceCount].sequenceLength;

			while (address < sequenceEnd)
			{
				currentBlock = (unsigned char *)((int)(&wordLookupDFAFP[currentGroupFP->nextWords]));

				// If current code is a regular letter
				if (*address < parametersFP->wordLookupDFA_numCodes)
				{
					
					currentWord = currentBlock[*address];
					currentGroupFP = (struct groupFP *)((int)(&wordLookupDFA_groupsFP[currentGroupFP->nextGroups + *address]));
					//currentGroupFP = &wordLookupDFA_groupsC[currentGroupFP->nextGroups + *address];
				}
				else
				{
					if (address >= sequenceEnd)
						break;

					currentWord = *currentBlock;
					currentGroupFP = (struct groupFP *)((int)(&wordLookupDFA_groupsFP[currentGroupFP->nextGroups]));
					//currentGroupFP = &wordLookupDFA_groupsC[currentGroupFP->nextGroups];
				}
				
				if (currentWord)
				{
					subjectOffset = address - subject;
					// At least one query position, stored at an extenal address
					queryOffsets = ((ushort*)currentBlock) - currentWord;
					
					if (!(*queryOffsets))
					{
						// Go to an outside address for additional positions
*queryOffsets = *wordLookupDFA_AddiPositions
                                     + (*(queryOffsets + 1) * constants_max_short) + *(queryOffsets + 2);
//*queryOffsets = *wordLookupDFA_AddiPositions
//                                     + (queryOffsets[1] * constants_max_short) + queryOffsets[2];
						//queryOffsets = wordLookupDFA_AddiPositions + (*((ushort*)((int)queryOffsets + 1 * sizeof(ushort*))) * constants_max_short) + (*(queryOffsets + 2));
					}

					do
					{
						queryOffset = *queryOffsets;
		
						#ifndef NO_STAGE2
						// Calculate the diagonal this hit is on
						diagonal = subjectOffset - queryOffset;

						// If we have not extended past this point on this diagonal
						lastHitFP = hitMatrix_Local + diagonal;
						
						if ((*lastHitFP) < address - (unsigned char *)((int)sequence))
						{
							//Number of extensions for each subject sequence
							blast_numUngappedExtensions[tid] ++;

							// If only one hit triggered this extension
							ungappedExtension_oneHitExtendD((unsigned char*)((int)sequence), 
									queryOffset,
									address, *PSSMatrixFP, subject, 
									&ungappedExtension_subjectEndReachedFP,
									parametersFP->encoding_numCodes,
									parametersFP->statistics_ungappedNominalDropoff,
									parametersFP->blast_ungappedNominalTrigger,
									ungappedExtension_current,
									&numOfTriggerExtensions,
									sequenceCount,
									tid);

							// Update furthest reached value for the diagonal
							*lastHitFP = ungappedExtension_subjectEndReachedFP;
						}
						#endif
					
						queryOffsets++; blast_numHits[tid]++;
					}
					while((*queryOffsets));
				}
				address++;
			}
		}
		//option=======================================================
		//sequenceCount = atomicAdd(&global_sequenceCount, 1);
		sequenceCount += get_global_size(1) * get_local_size(1);
//		sequenceCount += gridDim * blockDim;
		//============================================================
	}

	blast_numTriggerExtensions[tid] = (uint) numOfTriggerExtensions;
	return;
}

__global struct ungappedExtension *ungappedExtension_oneHitExtendD(unsigned char* sequenceStart,
						int queryOffset, 
						unsigned char *subjectHit, 
						struct PSSMatrixFP PSSMatrixFP, unsigned char *subject,
						uint *sequenceHitEnd, unsigned char encoding_numCodes,
						int statistics_ungappedNominalDropoff,
						int blast_ungappedNominalTrigger,
						struct ungappedExtension *ungappedExtension_extensions,
						uint *numOfTriggerExtensions,
						uint sequenceCount,
						int tid)
{
	short* queryPosition;
	//int queryPosition;
	unsigned char* subjectPosition, *subjectStart, *subjectEnd;
	int changeSinceBest = 0;
	int dropoff, originalDropoff;
	int ungappedExtension_bestScore;

	originalDropoff = dropoff = -statistics_ungappedNominalDropoff;	
	ungappedExtension_bestScore = 0;

	// Start at queryEnd,subjectEnd (right/last hit position)
	queryPosition = PSSMatrixFP.matrix + queryOffset * encoding_numCodes;
	//queryPosition = queryOffset + 1;
	subjectPosition = subjectStart = subjectHit;
	
	while (changeSinceBest > dropoff)
	{
		changeSinceBest += queryPosition[*subjectPosition];
		//changeSinceBest += scoreMatrixC[querySequenceC[queryPosition] * encoding_numCodes + (*subjectPosition)];

		// If we have got a positive score
		if (changeSinceBest > 0)
		{
			// Keep updating best score and resetting change-since-best
			// whilst we are reading positive scores
			do
			{
				ungappedExtension_bestScore += changeSinceBest;
				queryPosition = queryPosition - encoding_numCodes;
				//queryPosition = queryPosition - 1;
				subjectPosition--;

				changeSinceBest = queryPosition[*subjectPosition];
				//changeSinceBest = scoreMatrixC[querySequenceC[queryPosition] * encoding_numCodes + (*subjectPosition)];
			}
			while (changeSinceBest > 0);

			subjectStart = subjectPosition;
		}

		queryPosition = queryPosition - encoding_numCodes;
		//queryPosition = queryPosition - 1;
		subjectPosition--;
	}
	
	// Correct for extra decrement
	subjectStart++;

	// Starting at right/last hit position again
	queryPosition = PSSMatrixFP.matrix + (queryOffset + 1) * encoding_numCodes;
	//queryPosition = (queryOffset + 2);
	subjectPosition = subjectEnd = subjectHit + 1;
	changeSinceBest = 0;

	// May need to alter dropoff so we also dropoff if below zero
	if (-ungappedExtension_bestScore > originalDropoff)
	{
		dropoff = -ungappedExtension_bestScore;
	}

	// Extend end of alignment until dropoff
	while (changeSinceBest > dropoff)
	{
		//Shucai
		changeSinceBest += queryPosition[*subjectPosition];
		//changeSinceBest += scoreMatrixC[querySequenceC[queryPosition] * encoding_numCodes + (*subjectPosition)];
		
		// If we have got a positive score
		if (changeSinceBest > 0)
		{
			// Keep updating best score and resetting change-since-best
			// whilst we are reading positive scores
			do
			{
				ungappedExtension_bestScore += changeSinceBest;
				queryPosition = queryPosition + encoding_numCodes;
				//queryPosition = queryPosition + 1;

				subjectPosition++;
				changeSinceBest = queryPosition[*subjectPosition];
				//changeSinceBest = scoreMatrixC[querySequenceC[queryPosition] * encoding_numCodes + (*subjectPosition)];
			}
			while (changeSinceBest > 0);

			subjectEnd = subjectPosition;
			
			// Check need for change in dropoff
			if ((dropoff = -ungappedExtension_bestScore) < originalDropoff)
			{
				dropoff = originalDropoff;
			}
		}
		queryPosition = queryPosition + encoding_numCodes;
		//queryPosition = queryPosition + 1;

		subjectPosition++;
	}
	
	subjectEnd--;

	//*sequenceHitEnd = subjectPosition - subject;
	*sequenceHitEnd = subjectPosition - sequenceStart;

	if (ungappedExtension_bestScore >= blast_ungappedNominalTrigger)
	{
		int diagonal;
		struct ungappedExtension* newUngappedExtension = NULL;
		
		newUngappedExtension = &ungappedExtension_extensions[(*numOfTriggerExtensions)];
		// Calculate diagonal
		diagonal = (subjectHit - subject) - queryOffset;

		// Determine offsets from pointers
		newUngappedExtension->start.subjectOffset = subjectStart - subject;
		newUngappedExtension->end.subjectOffset = subjectEnd - subject;
		newUngappedExtension->start.queryOffset = newUngappedExtension->start.subjectOffset - diagonal;
		newUngappedExtension->end.queryOffset = newUngappedExtension->end.subjectOffset - diagonal;
		newUngappedExtension->seed = ungappedExtension_findProteinSeed(newUngappedExtension, 
									 PSSMatrixFP, subject, encoding_numCodes);

	//	newUngappedExtension->next = NULL;
		newUngappedExtension->nominalScore = ungappedExtension_bestScore;
		newUngappedExtension->status = ungappedExtension_UNGAPPED;
		newUngappedExtension->sequenceCount = sequenceCount;

		//Shucai
		//Record the number of hits satisfying the next step
		(*numOfTriggerExtensions)++;

		return (__global struct ungappedExtension*)((int)newUngappedExtension);
	}
	else
	{
		return NULL;
	}

}

struct coordinate ungappedExtension_findProteinSeed(
					struct ungappedExtension* ungappedExtension,
					struct PSSMatrixFP PSSMatrixFP, 
					unsigned char* subject, 
					unsigned char encoding_numCodes)
{
	short *queryWindowStart, *queryWindowEnd;
	unsigned char *subjectWindowStart, *subjectWindowEnd;

	short* bestQueryPosition;
	unsigned char* bestSubjectPosition;
	int bestSegmentScore;
	int nominalScore, count;
	struct coordinate seed;

	if (ungappedExtension->end.queryOffset - ungappedExtension->start.queryOffset < 11)
	{
		// The seed point is the middle of the extension
		seed.queryOffset = (ungappedExtension->end.queryOffset +
							ungappedExtension->start.queryOffset) / 2;
		seed.subjectOffset = (ungappedExtension->end.subjectOffset +
							  ungappedExtension->start.subjectOffset) / 2;
	}
	else
	{
		// Else find the highest scoring length-11 segment of the ungapped extension
		queryWindowStart = queryWindowEnd = PSSMatrixFP.matrix + ungappedExtension->start.queryOffset * encoding_numCodes;
		subjectWindowStart = subjectWindowEnd = subject + ungappedExtension->start.subjectOffset;

		// Find initial score for first 11 positions
		nominalScore = 0;
		count = 0;
		while (count < 11)
		{
			nominalScore += queryWindowEnd[*subjectWindowEnd];
			queryWindowEnd += encoding_numCodes;
			subjectWindowEnd++;
			count++;
		}

		queryWindowEnd -= encoding_numCodes;
		subjectWindowEnd--;

		// By default first-11 positions gives best position and score
		bestQueryPosition = queryWindowStart;
		bestSubjectPosition = subjectWindowStart;
		bestSegmentScore = nominalScore;

		// Now slide the window across and record the better scores/positions
		while (queryWindowEnd < PSSMatrixFP.matrix + ungappedExtension->end.queryOffset * encoding_numCodes)
		{
			// Advance window end, add new position value
			queryWindowEnd += encoding_numCodes;
			subjectWindowEnd++;

			nominalScore += queryWindowEnd[*subjectWindowEnd];
			// Remove position that we will leave behind
			nominalScore -= queryWindowStart[*subjectWindowStart];

			queryWindowStart += encoding_numCodes;
			subjectWindowStart++;

			// Check if best window position yet
			if (nominalScore > bestSegmentScore)
			{
				bestSegmentScore = nominalScore;
				bestQueryPosition = queryWindowStart;
				bestSubjectPosition = subjectWindowStart;
			}
		}

		// Middle of the best window is the seed position
		seed.queryOffset = (bestQueryPosition - PSSMatrixFP.matrix) / encoding_numCodes + 5;
		seed.subjectOffset = bestSubjectPosition + 5 - subject;
	}

	return seed;
}



//Embarrassingly parallel approach is used. One thread is used for
//the hit detection of one sequence
__kernel void search_protein2hitKernel(__global struct PSSMatrixFP *PSSMatrixFP,
										 __global short *matrixBody,
									  	 __global struct sequenceDataFP *sequenceDataFP, 
										 __global unsigned char *sequence,
										 __global struct parameters *parametersFP,
										 __global struct groupFP *wordLookupDFA_groupsFP,
										 __global unsigned char *wordLookupDFAFP,
										 __global uint *blast_numUngappedExtensions,
										 __global uint *blast_numTriggerExtensions,
										 __global uint *blast_numHits,
										 __global uint *hitMatrix_furthestp,
										 __global uint *hitMatrix_offsetp,
										 __global struct ungappedExtension * ungappedExtension_extensionsp,
										 uint nTotalSequenceNum)
{
	int tid = get_local_id(1) * get_local_size(1) + get_group_id(1);
//	int tid = blockIdx * blockDim + threadIdx;

	unsigned char *subject, *sequenceEnd, *address;
	int subjectOffset, count;
	unsigned char currentWord, *currentBlock;
	struct groupFP *currentGroupFP;
	ushort *wordLookupDFA_AddiPositions;
	uint numOfTriggerExtensions = 0;
	ushort *queryOffsets, queryOffset;
	struct ungappedExtension* ungappedExtension_current;
	struct ungappedExtension* ungappedExtension_additional;
	int diagonal;
	uint *lastHitFP;
	uint ungappedExtension_subjectEndReachedFP;
	uint *hitMatrix_Local;
	uint sequenceCount;
	int  distance;

//blast_numTriggerExtensions[tid]=tid;
//ungappedExtension_extensionsp[tid].status = -99;

	hitMatrix_Local = (uint *)((int)(hitMatrix_furthestp +  hitMatrix_offsetp[tid] + PSSMatrixFP->length));
	//ungappedExtension_current = ungappedExtension_extensionsp + tid * UNGAPEXT_PER_THREAD;
	ungappedExtension_extensionsp->start.subjectOffset = 0;
	ungappedExtension_current = (struct ungappedExtension *)((int)(ungappedExtension_extensionsp + tid * parametersFP->ungappedExtensionsPerThread));
	ungappedExtension_additional = (struct ungappedExtension *)((int)(ungappedExtension_extensionsp + parametersFP->ungappedExtAdditionalStartLoc));
	wordLookupDFA_AddiPositions = (ushort *)((int)(wordLookupDFAFP + 
								  parametersFP->additionalQueryPositionOffset));

	//Set the PSSMatrix body
	PSSMatrixFP->matrix = (short *)((int)matrixBody + parametersFP->encoding_numCodes);

	sequenceCount = tid;
	while (sequenceCount < nTotalSequenceNum)
	{
		subject = address = (unsigned char *)((int)(sequence + sequenceDataFP[sequenceCount].offset));
		
		if (sequenceDataFP[sequenceCount].sequenceLength >= parametersFP->parameters_wordSize)
		{
			currentGroupFP = (struct groupFP *)((int)(wordLookupDFA_groupsFP));

			count = 1;
			while (count < parametersFP->parameters_wordSize)
			{
				if (*address < parametersFP->wordLookupDFA_numCodes)
				{
					currentGroupFP = (struct groupFP *)((int)(&wordLookupDFA_groupsFP[currentGroupFP->nextGroups + *address]));
				}
				else
				{
					currentGroupFP = (struct groupFP *)((int)(&wordLookupDFA_groupsFP[currentGroupFP->nextGroups]));
				}
				address++;
				count++;
			}

			sequenceEnd = subject + sequenceDataFP[sequenceCount].sequenceLength;

			while (address < sequenceEnd)
			{
				currentBlock = (unsigned char *)((int)(&wordLookupDFAFP[currentGroupFP->nextWords]));

				// If current code is a regular letter
				if (*address < parametersFP->wordLookupDFA_numCodes)
				{
					currentWord = currentBlock[*address];
					currentGroupFP = (struct groupFP *)((int)(&wordLookupDFA_groupsFP[currentGroupFP->nextGroups + *address]));
				}
				else
				{
					if (address >= sequenceEnd)
						break;

					currentWord = *currentBlock;
					currentGroupFP = (struct groupFP *)((int)(&wordLookupDFA_groupsFP[currentGroupFP->nextGroups]));
				}
				
				if (currentWord)
				{
					subjectOffset = address - subject;
					// At least one query position, stored at an extenal address
					queryOffsets = ((ushort*)currentBlock) - currentWord;
					
					if (!(*queryOffsets))
					{
						// Go to an outside address for additional positions
						queryOffsets = wordLookupDFA_AddiPositions
									+ (*(queryOffsets + 1) * constants_max_short) + (*(queryOffsets + 2));
					}

					do
					{
						queryOffset = *queryOffsets;
		
						#ifndef NO_STAGE2
						// Calculate the diagonal this hit is on
						diagonal = subjectOffset - queryOffset;

						// If we have not extended past this point on this diagonal
						lastHitFP = hitMatrix_Local + diagonal;

						distance = (int)((address - (unsigned char*)((int)(sequence))) - *lastHitFP);
						if (distance >= parametersFP->parameters_A)
						{
							*lastHitFP = address - (unsigned char *)((int)(sequence));
						}
						else if (distance >= parametersFP->parameters_overlap)

						{
							//Number of extensions for each subject sequence
							blast_numUngappedExtensions[tid] ++;

							// If only one hit triggered this extension
							ungappedExtension_twoHitExtendD((unsigned char *)((int)sequence), 
									queryOffset,
									address, *lastHitFP, *PSSMatrixFP, subject, 
									&ungappedExtension_subjectEndReachedFP,
									parametersFP->encoding_numCodes,
									parametersFP->statistics_ungappedNominalDropoff,
									parametersFP->blast_ungappedNominalTrigger,
									parametersFP->ungappedExtensionsPerThread,
									ungappedExtension_current,
									ungappedExtension_additional,
									&numOfTriggerExtensions,
									sequenceCount,
									tid);

							// Update furthest reached value for the diagonal
							*lastHitFP = ungappedExtension_subjectEndReachedFP;
						}
						#endif
					
						queryOffsets++; blast_numHits[tid]++;
					}
					while((*queryOffsets));
				}
				address++;
			}
		}

		//option=======================================================
		//sequenceCount = atomicAdd(&global_sequenceCount, 1);
		sequenceCount += get_global_size(1) * get_local_size(1);
//		sequenceCount += gridDim * blockDim;
		//============================================================
	}


	return;
}
